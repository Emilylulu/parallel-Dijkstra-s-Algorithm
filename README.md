# parallel-Dijkstra-s-Algorithm
## Introduction
You need to write two programs, dijkstra_mpi and dijkstra_omp, that will take as input a single file (an adjacency matrix) and a source vertex ID and output to a file the weight of a shortest path from the source vertex to every other vertex. As the names suggest, the first program will use MPI and the second OpenMP for parallelizing the algorithm. The input file will consist of n+1 lines, with the first line containing only the number n, and each other line containing n values (i.e., a dense matrix), with each value representing the weight of the edge. You should assume that the values in the input file are represented as single-precision floats. An edge that does not exist in the graph is represented by the special value Inf. Your output file should also follow this convention.
## Parallelization Strategy
Feel free to try any parallelization strategy you wish, including strategies we discussed in class. The only requirement is that the input graph should be split and distributed to processes. The code should work for very large graphs that do not fit in the memory of a single node as long as they fit in the aggregate memory of the set of nodes tasked to execute the program
## Algorithm
For a given source node in the graph, dijkstra’s algorithm finds the shortest path between that node and every other.
1) For openmp, parallel finding the next node and update distance parts. Which means, for outer loop, renew the set which contains nodes that already in shortest new graph, this part stay still, can’t be paralleled. For two inner loops, which are finding the next node and update the distance for this new node, this part can be paralleled.
2) For openmpi, master node load the data and meanwhile send to other nodes. For every node, find the shortest distance and reduction to a shortest distance, then broadcast to all other nodes(implement with MPI_Allreduce function), put this node to shortest graph, then go to next iteration.
